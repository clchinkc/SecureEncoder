[
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "werkzeug.exceptions",
        "description": "werkzeug.exceptions",
        "isExtraImport": true,
        "detail": "werkzeug.exceptions",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "RotatingFileHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "Cipher",
        "importPath": "cryptography.hazmat.primitives.ciphers",
        "description": "cryptography.hazmat.primitives.ciphers",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.ciphers",
        "documentation": {}
    },
    {
        "label": "algorithms",
        "importPath": "cryptography.hazmat.primitives.ciphers",
        "description": "cryptography.hazmat.primitives.ciphers",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.ciphers",
        "documentation": {}
    },
    {
        "label": "modes",
        "importPath": "cryptography.hazmat.primitives.ciphers",
        "description": "cryptography.hazmat.primitives.ciphers",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.ciphers",
        "documentation": {}
    },
    {
        "label": "default_backend",
        "importPath": "cryptography.hazmat.backends",
        "description": "cryptography.hazmat.backends",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.backends",
        "documentation": {}
    },
    {
        "label": "rsa",
        "importPath": "cryptography.hazmat.primitives.asymmetric",
        "description": "cryptography.hazmat.primitives.asymmetric",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric",
        "documentation": {}
    },
    {
        "label": "padding",
        "importPath": "cryptography.hazmat.primitives.asymmetric",
        "description": "cryptography.hazmat.primitives.asymmetric",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric",
        "documentation": {}
    },
    {
        "label": "hashes",
        "importPath": "cryptography.hazmat.primitives",
        "description": "cryptography.hazmat.primitives",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives",
        "documentation": {}
    },
    {
        "label": "serialization",
        "importPath": "cryptography.hazmat.primitives",
        "description": "cryptography.hazmat.primitives",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives",
        "documentation": {}
    },
    {
        "label": "padding",
        "importPath": "cryptography.hazmat.primitives",
        "description": "cryptography.hazmat.primitives",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "SQLAlchemy",
        "importPath": "flask_sqlalchemy",
        "description": "flask_sqlalchemy",
        "isExtraImport": true,
        "detail": "flask_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "encode_base64",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_base64",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_hex",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_hex",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_utf8",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_utf8",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_latin1",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_latin1",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_ascii",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_ascii",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_url",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_url",
        "importPath": "src.encoder_decoder",
        "description": "src.encoder_decoder",
        "isExtraImport": true,
        "detail": "src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "ensure_aes_key",
        "importPath": "src.encryption_decryption",
        "description": "src.encryption_decryption",
        "isExtraImport": true,
        "detail": "src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "aes_encrypt",
        "importPath": "src.encryption_decryption",
        "description": "src.encryption_decryption",
        "isExtraImport": true,
        "detail": "src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "aes_decrypt",
        "importPath": "src.encryption_decryption",
        "description": "src.encryption_decryption",
        "isExtraImport": true,
        "detail": "src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "generate_rsa_keys",
        "importPath": "src.encryption_decryption",
        "description": "src.encryption_decryption",
        "isExtraImport": true,
        "detail": "src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "rsa_encrypt",
        "importPath": "src.encryption_decryption",
        "description": "src.encryption_decryption",
        "isExtraImport": true,
        "detail": "src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "rsa_decrypt",
        "importPath": "src.encryption_decryption",
        "description": "src.encryption_decryption",
        "isExtraImport": true,
        "detail": "src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "src.md5_model",
        "description": "src.md5_model",
        "isExtraImport": true,
        "detail": "src.md5_model",
        "documentation": {}
    },
    {
        "label": "MD5Hash",
        "importPath": "src.md5_model",
        "description": "src.md5_model",
        "isExtraImport": true,
        "detail": "src.md5_model",
        "documentation": {}
    },
    {
        "label": "md5_encode",
        "importPath": "src.md5_model",
        "description": "src.md5_model",
        "isExtraImport": true,
        "detail": "src.md5_model",
        "documentation": {}
    },
    {
        "label": "md5_decode",
        "importPath": "src.md5_model",
        "description": "src.md5_model",
        "isExtraImport": true,
        "detail": "src.md5_model",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "src.create_app",
        "description": "src.create_app",
        "isExtraImport": true,
        "detail": "src.create_app",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "src.app",
        "description": "src.app",
        "isExtraImport": true,
        "detail": "src.app",
        "documentation": {}
    },
    {
        "label": "stringify",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def home():\n    app.logger.debug('This is a debug message, visible only in development')\n    app.logger.warning('This warning is logged in production')\n    return \"Hello, check your log configuration based on the environment.\"\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\n@app.route('/api/upload_key', methods=['POST'])\ndef upload_key():\n    file = request.files['file']\n    if file.filename == '':",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "allowed_file",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\n@app.route('/api/upload_key', methods=['POST'])\ndef upload_key():\n    file = request.files['file']\n    if file.filename == '':\n        app.logger.error(\"No file selected for upload\")\n        return jsonify({'error': 'No file selected'}), 400\n    if file and allowed_file(file.filename):\n        filename = secure_filename(file.filename)",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "upload_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def upload_key():\n    file = request.files['file']\n    if file.filename == '':\n        app.logger.error(\"No file selected for upload\")\n        return jsonify({'error': 'No file selected'}), 400\n    if file and allowed_file(file.filename):\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return jsonify({'message': 'File uploaded successfully', 'filename': filename}), 201\n    app.logger.error(\"Invalid file type, a '.pem' file is needed\")",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "list_files",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def list_files():\n    files = [f for f in os.listdir(app.config['UPLOAD_FOLDER']) if os.path.isfile(os.path.join(app.config['UPLOAD_FOLDER'], f))]\n    return jsonify(files), 200\n@app.route('/api/download_key/<filename>')\ndef download_key(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    if not os.path.exists(file_path):\n        app.logger.error(\"File not found\")\n        return jsonify({'error': 'Key not found'}), 404\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename, as_attachment=True)",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "download_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def download_key(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    if not os.path.exists(file_path):\n        app.logger.error(\"File not found\")\n        return jsonify({'error': 'Key not found'}), 404\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename, as_attachment=True)\n@app.route('/api/delete_key/<filename>', methods=['DELETE'])\ndef delete_key(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))\n    if os.path.exists(file_path):",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "delete_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def delete_key(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        return jsonify({'message': 'File deleted successfully'}), 204\n    else:\n        return jsonify({'error': 'File not found'}), 404\n@app.route('/api/save_text', methods=['PATCH'])\ndef save_text():\n    data = request.get_json()",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "save_text",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def save_text():\n    data = request.get_json()\n    current_text = session.get('text', None)\n    new_text = data.get('new_text', None)\n    if current_text is None and new_text is None:\n        return jsonify({'message': 'No text provided'}), 400\n    elif current_text is None and new_text is not None:\n        session['text'] = new_text\n        return jsonify({'message': 'Text created successfully', 'text': new_text}), 201\n    elif current_text is not None and new_text is None:",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "process_text",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def process_text():\n    data = request.get_json()\n    session['text'] = data['text']\n    session['operation'] = data['operation']\n    session['action'] = data['action']\n    operations = {\n        'encode': {\n            'base64': encode_base64,\n            'hex': encode_hex,\n            'utf8': encode_utf8,",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "apply_security_headers",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def apply_security_headers(response):\n    response.headers[\"Content-Security-Policy\"] = \"default-src 'self'; script-src 'self'; object-src 'none';\"\n    response.headers[\"X-Frame-Options\"] = \"SAMEORIGIN\"\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n    response.headers[\"Referrer-Policy\"] = \"no-referrer\"\n    return response\n@app.after_request\ndef add_session_to_response(response):\n    response.set_cookie('files', json.dumps(session.get('files', [])))",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "add_session_to_response",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def add_session_to_response(response):\n    response.set_cookie('files', json.dumps(session.get('files', [])))\n    response.set_cookie('result', session.get('result', ''))\n    response.set_cookie('operation', session.get('operation', ''))\n    response.set_cookie('action', session.get('action', ''))\n    response.set_cookie('text', session.get('text', ''))\n    return response\n@app.errorhandler(Exception)\ndef handle_exception(e):\n    if isinstance(e, HTTPException):",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "handle_exception",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def handle_exception(e):\n    if isinstance(e, HTTPException):\n        return e\n    app.logger.error(f\"Unhandled exception: {str(e)}\")\n    return jsonify({'error': str(e)}), 500 if isinstance(e, KeyError) or isinstance(e, ValueError) else 400\ndef main():\n    app.run(host='0.0.0.0', port=int(os.environ.get('FLASK_PORT', '5000')))",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "def main():\n    app.run(host='0.0.0.0', port=int(os.environ.get('FLASK_PORT', '5000')))",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "SecureEncoderFlask.src.app",
        "description": "SecureEncoderFlask.src.app",
        "peekOfCode": "app = create_app()\nwith app.app_context():\n    db.create_all()\n    faker = Faker()\n    populate_db(faker, 1000)\nsetup_logger(app)\n@app.route('/')\ndef home():\n    app.logger.debug('This is a debug message, visible only in development')\n    app.logger.warning('This warning is logged in production')",
        "detail": "SecureEncoderFlask.src.app",
        "documentation": {}
    },
    {
        "label": "create_app",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.create_app",
        "description": "SecureEncoderFlask.src.create_app",
        "peekOfCode": "def create_app(test_config=None):\n    app = Flask(__name__, instance_relative_config=True)\n    # Default configuration\n    app.config.from_mapping(\n        UPLOAD_FOLDER=os.path.join(app.root_path, 'keys'),\n        ALLOWED_EXTENSIONS={'pem'},\n        SQLALCHEMY_DATABASE_URI=os.environ.get('DATABASE_URL', 'sqlite:///md5.db'),\n        SQLALCHEMY_TRACK_MODIFICATIONS=False,\n        SECRET_KEY=os.urandom(24),\n    )",
        "detail": "SecureEncoderFlask.src.create_app",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.create_app",
        "description": "SecureEncoderFlask.src.create_app",
        "peekOfCode": "def setup_logger(app):\n    if app.debug or os.getenv('FLASK_DEBUG') == '1':\n        app.logger.setLevel(logging.DEBUG)\n    else:\n        app.logger.setLevel(logging.WARNING)\n        # Create a file handler for production logs\n        file_handler = RotatingFileHandler('production.log', maxBytes=1024 * 1024 * 100, backupCount=10)\n        file_handler.setLevel(logging.WARNING)\n        formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)",
        "detail": "SecureEncoderFlask.src.create_app",
        "documentation": {}
    },
    {
        "label": "encode_base64",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def encode_base64(input_text: str) -> str:\n    \"\"\"Encode a string using Base64.\"\"\"\n    return base64.b64encode(input_text.encode()).decode()\ndef decode_base64(encoded_text: str) -> str:\n    \"\"\"Decode a Base64 encoded string.\"\"\"\n    return base64.b64decode(encoded_text.encode()).decode()\ndef encode_hex(input_text: str) -> str:\n    \"\"\"Encode a string using Hex encoding.\"\"\"\n    return binascii.hexlify(input_text.encode()).decode()\ndef decode_hex(encoded_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_base64",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def decode_base64(encoded_text: str) -> str:\n    \"\"\"Decode a Base64 encoded string.\"\"\"\n    return base64.b64decode(encoded_text.encode()).decode()\ndef encode_hex(input_text: str) -> str:\n    \"\"\"Encode a string using Hex encoding.\"\"\"\n    return binascii.hexlify(input_text.encode()).decode()\ndef decode_hex(encoded_text: str) -> str:\n    \"\"\"Decode a Hex encoded string.\"\"\"\n    return binascii.unhexlify(encoded_text.encode()).decode()\ndef encode_utf8(input_text: str) -> bytes:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_hex",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def encode_hex(input_text: str) -> str:\n    \"\"\"Encode a string using Hex encoding.\"\"\"\n    return binascii.hexlify(input_text.encode()).decode()\ndef decode_hex(encoded_text: str) -> str:\n    \"\"\"Decode a Hex encoded string.\"\"\"\n    return binascii.unhexlify(encoded_text.encode()).decode()\ndef encode_utf8(input_text: str) -> bytes:\n    \"\"\"Encode a string using UTF-8.\"\"\"\n    return input_text.encode('utf-8').hex()\ndef decode_utf8(encoded_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_hex",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def decode_hex(encoded_text: str) -> str:\n    \"\"\"Decode a Hex encoded string.\"\"\"\n    return binascii.unhexlify(encoded_text.encode()).decode()\ndef encode_utf8(input_text: str) -> bytes:\n    \"\"\"Encode a string using UTF-8.\"\"\"\n    return input_text.encode('utf-8').hex()\ndef decode_utf8(encoded_text: str) -> str:\n    \"\"\"Decode a UTF-8 encoded byte array.\"\"\"\n    return bytes.fromhex(encoded_text).decode('utf-8')\ndef encode_latin1(input_text: str) -> bytes:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_utf8",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def encode_utf8(input_text: str) -> bytes:\n    \"\"\"Encode a string using UTF-8.\"\"\"\n    return input_text.encode('utf-8').hex()\ndef decode_utf8(encoded_text: str) -> str:\n    \"\"\"Decode a UTF-8 encoded byte array.\"\"\"\n    return bytes.fromhex(encoded_text).decode('utf-8')\ndef encode_latin1(input_text: str) -> bytes:\n    \"\"\"Encode a string using ISO-8859-1 (Latin-1).\"\"\"\n    return input_text.encode('iso-8859-1').hex()\ndef decode_latin1(encoded_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_utf8",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def decode_utf8(encoded_text: str) -> str:\n    \"\"\"Decode a UTF-8 encoded byte array.\"\"\"\n    return bytes.fromhex(encoded_text).decode('utf-8')\ndef encode_latin1(input_text: str) -> bytes:\n    \"\"\"Encode a string using ISO-8859-1 (Latin-1).\"\"\"\n    return input_text.encode('iso-8859-1').hex()\ndef decode_latin1(encoded_text: str) -> str:\n    \"\"\"Decode a ISO-8859-1 (Latin-1) encoded byte array.\"\"\"\n    return bytes.fromhex(encoded_text).decode('iso-8859-1')\ndef encode_ascii(input_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_latin1",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def encode_latin1(input_text: str) -> bytes:\n    \"\"\"Encode a string using ISO-8859-1 (Latin-1).\"\"\"\n    return input_text.encode('iso-8859-1').hex()\ndef decode_latin1(encoded_text: str) -> str:\n    \"\"\"Decode a ISO-8859-1 (Latin-1) encoded byte array.\"\"\"\n    return bytes.fromhex(encoded_text).decode('iso-8859-1')\ndef encode_ascii(input_text: str) -> str:\n    \"\"\"Encode a string to ASCII values separated by spaces.\"\"\"\n    return ' '.join(str(ord(char)) for char in input_text)\ndef decode_ascii(encoded_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_latin1",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def decode_latin1(encoded_text: str) -> str:\n    \"\"\"Decode a ISO-8859-1 (Latin-1) encoded byte array.\"\"\"\n    return bytes.fromhex(encoded_text).decode('iso-8859-1')\ndef encode_ascii(input_text: str) -> str:\n    \"\"\"Encode a string to ASCII values separated by spaces.\"\"\"\n    return ' '.join(str(ord(char)) for char in input_text)\ndef decode_ascii(encoded_text: str) -> str:\n    \"\"\"Decode ASCII values separated by spaces to a string.\"\"\"\n    return ''.join(chr(int(code)) for code in encoded_text.split())\ndef encode_url(input_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_ascii",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def encode_ascii(input_text: str) -> str:\n    \"\"\"Encode a string to ASCII values separated by spaces.\"\"\"\n    return ' '.join(str(ord(char)) for char in input_text)\ndef decode_ascii(encoded_text: str) -> str:\n    \"\"\"Decode ASCII values separated by spaces to a string.\"\"\"\n    return ''.join(chr(int(code)) for code in encoded_text.split())\ndef encode_url(input_text: str) -> str:\n    \"\"\"Encode a string for safe URL transmission.\"\"\"\n    return urllib.parse.quote(input_text)\ndef decode_url(encoded_text: str) -> str:",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_ascii",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def decode_ascii(encoded_text: str) -> str:\n    \"\"\"Decode ASCII values separated by spaces to a string.\"\"\"\n    return ''.join(chr(int(code)) for code in encoded_text.split())\ndef encode_url(input_text: str) -> str:\n    \"\"\"Encode a string for safe URL transmission.\"\"\"\n    return urllib.parse.quote(input_text)\ndef decode_url(encoded_text: str) -> str:\n    \"\"\"Decode a URL-encoded string.\"\"\"\n    return urllib.parse.unquote(encoded_text)",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "encode_url",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def encode_url(input_text: str) -> str:\n    \"\"\"Encode a string for safe URL transmission.\"\"\"\n    return urllib.parse.quote(input_text)\ndef decode_url(encoded_text: str) -> str:\n    \"\"\"Decode a URL-encoded string.\"\"\"\n    return urllib.parse.unquote(encoded_text)",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "decode_url",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encoder_decoder",
        "description": "SecureEncoderFlask.src.encoder_decoder",
        "peekOfCode": "def decode_url(encoded_text: str) -> str:\n    \"\"\"Decode a URL-encoded string.\"\"\"\n    return urllib.parse.unquote(encoded_text)",
        "detail": "SecureEncoderFlask.src.encoder_decoder",
        "documentation": {}
    },
    {
        "label": "ensure_aes_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def ensure_aes_key(key_file):\n    \"\"\"Ensure there is an AES key available, and return it.\"\"\"\n    if not os.path.exists(key_file):\n        key = os.urandom(32)  # AES-256 key\n        with open(key_file, 'wb') as kf:\n            kf.write(key)\n        print(f\"New AES key generated and saved to {key_file}\")\n    else:\n        with open(key_file, 'rb') as kf:\n            key = kf.read()",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "aes_encrypt",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def aes_encrypt(plaintext: str, key: bytes):\n    \"\"\"Encrypt a string using AES encryption with the provided key.\"\"\"\n    # Generate a random IV\n    iv = os.urandom(16)\n    # Create a Cipher object\n    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())\n    encryptor = cipher.encryptor()\n    # Encrypt the plaintext\n    ciphertext = encryptor.update(plaintext.encode()) + encryptor.finalize()\n    # Return IV + Ciphertext for decryption",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "aes_decrypt",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def aes_decrypt(ciphertext_hex: str, key: bytes):\n    \"\"\"Decrypt a string using AES decryption with the provided key.\"\"\"\n    ciphertext = bytes.fromhex(ciphertext_hex)\n    # Extract IV from the beginning of the ciphertext\n    iv = ciphertext[:16]\n    actual_ciphertext = ciphertext[16:]\n    # Create a Cipher object\n    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())\n    decryptor = cipher.decryptor()\n    # Decrypt the ciphertext",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "generate_rsa_keys",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def generate_rsa_keys():\n    \"\"\"Generate RSA private and public keys.\"\"\"\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n        backend=default_backend()\n    )\n    public_key = private_key.public_key()\n    return private_key, public_key\ndef save_rsa_key(key, key_file, is_private=True):",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "save_rsa_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def save_rsa_key(key, key_file, is_private=True):\n    \"\"\"Save an RSA key (private or public) to a file.\"\"\"\n    with open(key_file, \"wb\") as kf:\n        if is_private:\n            kf.write(key.private_bytes(\n                encoding=serialization.Encoding.PEM,\n                format=serialization.PrivateFormat.PKCS8,\n                encryption_algorithm=serialization.NoEncryption()\n            ))\n        else:",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "ensure_rsa_public_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def ensure_rsa_public_key(public_key_file):\n    \"\"\"Ensure the RSA public key is available and return it.\"\"\"\n    if not os.path.exists(public_key_file):\n        # If the public key is missing, generate both keys to ensure matching pairs\n        private_key_file = public_key_file.replace(\"public\", \"private\")\n        if not os.path.exists(private_key_file):\n            private_key, public_key = generate_rsa_keys()\n            save_rsa_key(private_key, private_key_file, is_private=True)\n            save_rsa_key(public_key, public_key_file, is_private=False)\n        else:",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "ensure_rsa_private_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def ensure_rsa_private_key(private_key_file):\n    \"\"\"Ensure the RSA private key is available and return it.\"\"\"\n    if not os.path.exists(private_key_file):\n        # If the private key is missing, generate both keys to ensure matching pairs\n        public_key_file = private_key_file.replace(\"private\", \"public\")\n        private_key, public_key = generate_rsa_keys()\n        save_rsa_key(private_key, private_key_file, is_private=True)\n        save_rsa_key(public_key, public_key_file, is_private=False)\n    else:\n        # Load the existing private key",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "rsa_encrypt",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def rsa_encrypt(plaintext: str, public_key):\n    \"\"\"Encrypt a string using RSA public key.\"\"\"\n    ciphertext = public_key.encrypt(\n        plaintext.encode(),\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "rsa_decrypt",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.encryption_decryption",
        "description": "SecureEncoderFlask.src.encryption_decryption",
        "peekOfCode": "def rsa_decrypt(ciphertext_hex: str, private_key):\n    \"\"\"Decrypt a string using RSA private key.\"\"\"\n    ciphertext = bytes.fromhex(ciphertext_hex)\n    plaintext = private_key.decrypt(\n        ciphertext,\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )",
        "detail": "SecureEncoderFlask.src.encryption_decryption",
        "documentation": {}
    },
    {
        "label": "MD5Hash",
        "kind": 6,
        "importPath": "SecureEncoderFlask.src.md5_model",
        "description": "SecureEncoderFlask.src.md5_model",
        "peekOfCode": "class MD5Hash(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    text = db.Column(db.String(255), unique=True, nullable=False)\n    md5_hash = db.Column(db.String(32), unique=True, nullable=False)\n    def __init__(self, text, md5_hash):\n        self.text = text\n        self.md5_hash = md5_hash\ndef md5_encode(text):\n    hash_object = hashlib.md5(text.encode())\n    hash_hex = hash_object.hexdigest()",
        "detail": "SecureEncoderFlask.src.md5_model",
        "documentation": {}
    },
    {
        "label": "md5_encode",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.md5_model",
        "description": "SecureEncoderFlask.src.md5_model",
        "peekOfCode": "def md5_encode(text):\n    hash_object = hashlib.md5(text.encode())\n    hash_hex = hash_object.hexdigest()\n    existing_hash = MD5Hash.query.filter_by(md5_hash=hash_hex).first()\n    if not existing_hash:\n        new_hash = MD5Hash(text, hash_hex)\n        db.session.add(new_hash)\n        db.session.commit()\n    return hash_hex\ndef md5_decode(hash_hex):",
        "detail": "SecureEncoderFlask.src.md5_model",
        "documentation": {}
    },
    {
        "label": "md5_decode",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.md5_model",
        "description": "SecureEncoderFlask.src.md5_model",
        "peekOfCode": "def md5_decode(hash_hex):\n    match = MD5Hash.query.filter_by(md5_hash=hash_hex).first()\n    if match:\n        return match.text\n    return \"No match found\"\ndef populate_db(faker, num_entries=1000):\n    for _ in range(num_entries):\n        sentence = faker.sentence()\n        md5_encode(sentence)",
        "detail": "SecureEncoderFlask.src.md5_model",
        "documentation": {}
    },
    {
        "label": "populate_db",
        "kind": 2,
        "importPath": "SecureEncoderFlask.src.md5_model",
        "description": "SecureEncoderFlask.src.md5_model",
        "peekOfCode": "def populate_db(faker, num_entries=1000):\n    for _ in range(num_entries):\n        sentence = faker.sentence()\n        md5_encode(sentence)",
        "detail": "SecureEncoderFlask.src.md5_model",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "SecureEncoderFlask.src.md5_model",
        "description": "SecureEncoderFlask.src.md5_model",
        "peekOfCode": "db = SQLAlchemy()\nclass MD5Hash(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    text = db.Column(db.String(255), unique=True, nullable=False)\n    md5_hash = db.Column(db.String(32), unique=True, nullable=False)\n    def __init__(self, text, md5_hash):\n        self.text = text\n        self.md5_hash = md5_hash\ndef md5_encode(text):\n    hash_object = hashlib.md5(text.encode())",
        "detail": "SecureEncoderFlask.src.md5_model",
        "documentation": {}
    },
    {
        "label": "test_encode_base64",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_encode_base64():\n    \"\"\"Test Base64 encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"SGVsbG8sIFdvcmxkIQ==\"\n    assert encode_base64(input_text) == expected_output, \"Base64 encoding failed\"\ndef test_decode_base64():\n    \"\"\"Test decoding of a Base64-encoded string.\"\"\"\n    encoded_text = \"SGVsbG8sIFdvcmxkIQ==\"\n    expected_output = \"Hello, World!\"\n    assert decode_base64(encoded_text) == expected_output, \"Base64 decoding failed\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_decode_base64",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_decode_base64():\n    \"\"\"Test decoding of a Base64-encoded string.\"\"\"\n    encoded_text = \"SGVsbG8sIFdvcmxkIQ==\"\n    expected_output = \"Hello, World!\"\n    assert decode_base64(encoded_text) == expected_output, \"Base64 decoding failed\"\ndef test_encode_hex():\n    \"\"\"Test Hex encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"48656c6c6f2c20576f726c6421\"\n    assert encode_hex(input_text) == expected_output, \"Hex encoding failed\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_encode_hex",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_encode_hex():\n    \"\"\"Test Hex encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"48656c6c6f2c20576f726c6421\"\n    assert encode_hex(input_text) == expected_output, \"Hex encoding failed\"\ndef test_decode_hex():\n    \"\"\"Test decoding of a Hex-encoded string.\"\"\"\n    encoded_text = \"48656c6c6f2c20576f726c6421\"\n    expected_output = \"Hello, World!\"\n    assert decode_hex(encoded_text) == expected_output, \"Hex decoding failed\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_decode_hex",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_decode_hex():\n    \"\"\"Test decoding of a Hex-encoded string.\"\"\"\n    encoded_text = \"48656c6c6f2c20576f726c6421\"\n    expected_output = \"Hello, World!\"\n    assert decode_hex(encoded_text) == expected_output, \"Hex decoding failed\"\ndef test_encode_utf8():\n    \"\"\"Test UTF-8 encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"48656c6c6f2c20576f726c6421\"\n    encoded_text = encode_utf8(input_text)",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_encode_utf8",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_encode_utf8():\n    \"\"\"Test UTF-8 encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"48656c6c6f2c20576f726c6421\"\n    encoded_text = encode_utf8(input_text)\n    assert encoded_text == expected_output, f\"UTF-8 encoding failed: {encoded_text} != {expected_output}\"\ndef test_decode_utf8():\n    \"\"\"Test decoding of a UTF-8 encoded byte array.\"\"\"\n    input_bytes = \"48656c6c6f2c20576f726c6421\"\n    expected_output = \"Hello, World!\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_decode_utf8",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_decode_utf8():\n    \"\"\"Test decoding of a UTF-8 encoded byte array.\"\"\"\n    input_bytes = \"48656c6c6f2c20576f726c6421\"\n    expected_output = \"Hello, World!\"\n    output_text = decode_utf8(input_bytes)\n    assert output_text == expected_output, f\"UTF-8 decoding failed: {output_text} != {expected_output}\"\ndef test_encode_latin1():\n    \"\"\"Test Latin-1 encoding of a string.\"\"\"\n    input_text = \"Café\"\n    expected_output = \"436166e9\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_encode_latin1",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_encode_latin1():\n    \"\"\"Test Latin-1 encoding of a string.\"\"\"\n    input_text = \"Café\"\n    expected_output = \"436166e9\"\n    encoded_text = encode_latin1(input_text)\n    assert encoded_text == expected_output, f\"Latin-1 encoding failed: {encoded_text} != {expected_output}\"\ndef test_decode_latin1():\n    \"\"\"Test decoding of a Latin-1 encoded byte array.\"\"\"\n    input_bytes = \"436166e9\"\n    expected_output = \"Café\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_decode_latin1",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_decode_latin1():\n    \"\"\"Test decoding of a Latin-1 encoded byte array.\"\"\"\n    input_bytes = \"436166e9\"\n    expected_output = \"Café\"\n    output_text = decode_latin1(input_bytes)\n    assert output_text == expected_output, f\"Latin-1 decoding failed: {output_text} != {expected_output}\"\ndef test_encode_ascii():\n    \"\"\"Test ASCII encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"72 101 108 108 111 44 32 87 111 114 108 100 33\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_encode_ascii",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_encode_ascii():\n    \"\"\"Test ASCII encoding of a string.\"\"\"\n    input_text = \"Hello, World!\"\n    expected_output = \"72 101 108 108 111 44 32 87 111 114 108 100 33\"\n    encoded_text = encode_ascii(input_text)\n    assert encoded_text == expected_output, f\"ASCII encoding failed: {encoded_text} != {expected_output}\"\ndef test_decode_ascii():\n    \"\"\"Test decoding of an ASCII-encoded string.\"\"\"\n    encoded_text = \"72 101 108 108 111 44 32 87 111 114 108 100 33\"\n    expected_output = \"Hello, World!\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_decode_ascii",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_decode_ascii():\n    \"\"\"Test decoding of an ASCII-encoded string.\"\"\"\n    encoded_text = \"72 101 108 108 111 44 32 87 111 114 108 100 33\"\n    expected_output = \"Hello, World!\"\n    output_text = decode_ascii(encoded_text)\n    assert output_text == expected_output, f\"ASCII decoding failed: {output_text} != {expected_output}\"\ndef test_encode_url():\n    \"\"\"Test URL encoding of a string.\"\"\"\n    input_text = \"Hello, World! @2023\"\n    expected_output = \"Hello%2C%20World%21%20%402023\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_encode_url",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_encode_url():\n    \"\"\"Test URL encoding of a string.\"\"\"\n    input_text = \"Hello, World! @2023\"\n    expected_output = \"Hello%2C%20World%21%20%402023\"\n    encoded_text = encode_url(input_text)\n    assert encoded_text == expected_output, f\"URL encoding failed: {encoded_text} != {expected_output}\"\ndef test_decode_url():\n    \"\"\"Test decoding of a URL-encoded string.\"\"\"\n    encoded_text = \"Hello%2C%20World%21%20%402023\"\n    expected_output = \"Hello, World! @2023\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "test_decode_url",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encoder_decoder",
        "description": "SecureEncoderFlask.tests.test_encoder_decoder",
        "peekOfCode": "def test_decode_url():\n    \"\"\"Test decoding of a URL-encoded string.\"\"\"\n    encoded_text = \"Hello%2C%20World%21%20%402023\"\n    expected_output = \"Hello, World! @2023\"\n    output_text = decode_url(encoded_text)\n    assert output_text == expected_output, f\"URL decoding failed: {output_text} != {expected_output}\"",
        "detail": "SecureEncoderFlask.tests.test_encoder_decoder",
        "documentation": {}
    },
    {
        "label": "setup_module",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def setup_module(module):\n    \"\"\" Setup any state specific to the execution of the given module.\"\"\"\n    global original_key_file\n    original_key_file = \"aes_key.bin\"  # This should match your production key file path\n    global test_key_file\n    test_key_file = \"tests/test_aes_key.bin\"\n    # Ensure the test directory exists\n    os.makedirs(os.path.dirname(test_key_file), exist_ok=True)\ndef teardown_module(module):\n    \"\"\" Teardown any state that was previously setup with a setup_module method.\"\"\"",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "teardown_module",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def teardown_module(module):\n    \"\"\" Teardown any state that was previously setup with a setup_module method.\"\"\"\n    if os.path.exists(test_key_file):\n        os.remove(test_key_file)\ndef test_ensure_aes_key_generation():\n    \"\"\"Test that a new key is generated when the key file is missing.\"\"\"\n    assert not os.path.exists(test_key_file), \"Key file should not exist before the test\"\n    key = ensure_aes_key(test_key_file)\n    assert os.path.exists(test_key_file), \"Key file should be created after calling ensure_aes_key\"\n    with open(test_key_file, 'rb') as f:",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_ensure_aes_key_generation",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_ensure_aes_key_generation():\n    \"\"\"Test that a new key is generated when the key file is missing.\"\"\"\n    assert not os.path.exists(test_key_file), \"Key file should not exist before the test\"\n    key = ensure_aes_key(test_key_file)\n    assert os.path.exists(test_key_file), \"Key file should be created after calling ensure_aes_key\"\n    with open(test_key_file, 'rb') as f:\n        assert f.read() == key, \"Key file should contain the generated key\"\ndef test_ensure_aes_key_retrieval():\n    \"\"\"Test that an existing key is retrieved when the key file is present.\"\"\"\n    key = os.urandom(32)",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_ensure_aes_key_retrieval",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_ensure_aes_key_retrieval():\n    \"\"\"Test that an existing key is retrieved when the key file is present.\"\"\"\n    key = os.urandom(32)\n    with open(test_key_file, 'wb') as f:\n        f.write(key)\n    assert os.path.exists(test_key_file), \"Key file should exist before the test\"\n    retrieved_key = ensure_aes_key(test_key_file)\n    assert retrieved_key == key, \"Retrieved key should match the one in the key file\"\ndef test_aes_encrypt_decrypt():\n    \"\"\"Test that text is correctly encrypted and decrypted back to its original form.\"\"\"",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_aes_encrypt_decrypt",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_aes_encrypt_decrypt():\n    \"\"\"Test that text is correctly encrypted and decrypted back to its original form.\"\"\"\n    key = os.urandom(32)  # Generate a new key for each test to ensure isolation\n    plaintext = \"Hello, World!\"\n    encrypted = aes_encrypt(plaintext, key)\n    decrypted = aes_decrypt(encrypted, key)\n    assert decrypted == plaintext, \"Decrypted text should match the original\"\ndef test_aes_encryption_decryption_empty_string():\n    \"\"\"Test encryption and decryption of an empty string.\"\"\"\n    key = os.urandom(32)",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_aes_encryption_decryption_empty_string",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_aes_encryption_decryption_empty_string():\n    \"\"\"Test encryption and decryption of an empty string.\"\"\"\n    key = os.urandom(32)\n    plaintext = \"\"\n    encrypted = aes_encrypt(plaintext, key)\n    decrypted = aes_decrypt(encrypted, key)\n    assert decrypted == plaintext, \"Decrypted text should be an empty string for empty input\"\ndef test_aes_encryption_uniqueness():\n    \"\"\"Test that encrypting the same text with different keys results in different ciphertexts.\"\"\"\n    plaintext = \"Repeatable text\"",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_aes_encryption_uniqueness",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_aes_encryption_uniqueness():\n    \"\"\"Test that encrypting the same text with different keys results in different ciphertexts.\"\"\"\n    plaintext = \"Repeatable text\"\n    key1 = os.urandom(32)\n    key2 = os.urandom(32)\n    encrypted1 = aes_encrypt(plaintext, key1)\n    encrypted2 = aes_encrypt(plaintext, key2)\n    assert encrypted1 != encrypted2, \"Encryption with different keys should produce different outputs\"\ndef test_aes_encryption_with_padding():\n    \"\"\"Test that encryption and decryption correctly handle padding for block alignment.\"\"\"",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_aes_encryption_with_padding",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_aes_encryption_with_padding():\n    \"\"\"Test that encryption and decryption correctly handle padding for block alignment.\"\"\"\n    key = os.urandom(32)\n    padder = padding.PKCS7(128).padder()  # 128 bit (16 byte) block size for AES\n    plaintext = \"Text not block aligned\"\n    padded_plaintext = padder.update(plaintext.encode()) + padder.finalize()\n    encrypted = aes_encrypt(padded_plaintext.hex(), key)\n    decrypted = aes_decrypt(encrypted, key)\n    unpadder = padding.PKCS7(128).unpadder()\n    unpadded_plaintext = unpadder.update(bytes.fromhex(decrypted)) + unpadder.finalize()",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_aes_encryption_decryption_invalid_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_aes_encryption_decryption_invalid_key():\n    \"\"\"Test that decryption fails with an incorrect key.\"\"\"\n    key = os.urandom(32)\n    plaintext = \"Secret message\"\n    encrypted = aes_encrypt(plaintext, key)\n    wrong_key = os.urandom(32)\n    try:\n        decrypted = aes_decrypt(encrypted, wrong_key)\n        assert False, \"Decryption should fail with an incorrect key\"\n    except ValueError as e:",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_encrypt_decrypt",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_encrypt_decrypt():\n    \"\"\"Test that text is correctly encrypted and decrypted back to its original form using RSA.\"\"\"\n    private_key, public_key = generate_rsa_keys()\n    plaintext = \"Hello, RSA World!\"\n    encrypted = rsa_encrypt(plaintext, public_key)\n    decrypted = rsa_decrypt(encrypted, private_key)\n    assert decrypted == plaintext, \"Decrypted text should match the original plaintext\"\ndef test_rsa_encryption_uniqueness():\n    \"\"\"Test that RSA encryption of the same text results in different ciphertexts.\"\"\"\n    _, public_key = generate_rsa_keys()",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_encryption_uniqueness",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_encryption_uniqueness():\n    \"\"\"Test that RSA encryption of the same text results in different ciphertexts.\"\"\"\n    _, public_key = generate_rsa_keys()\n    plaintext = \"Repeatable text\"\n    encrypted1 = rsa_encrypt(plaintext, public_key)\n    encrypted2 = rsa_encrypt(plaintext, public_key)\n    assert encrypted1 != encrypted2, \"RSA encryption should produce different outputs for the same input\"\ndef test_rsa_encrypt_decrypt_with_multiple_keys():\n    \"\"\"Test RSA encryption and decryption using multiple key pairs.\"\"\"\n    private_key1, public_key1 = generate_rsa_keys()",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_encrypt_decrypt_with_multiple_keys",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_encrypt_decrypt_with_multiple_keys():\n    \"\"\"Test RSA encryption and decryption using multiple key pairs.\"\"\"\n    private_key1, public_key1 = generate_rsa_keys()\n    private_key2, public_key2 = generate_rsa_keys()\n    plaintext = \"Shared Secret!\"\n    encrypted_with_key1 = rsa_encrypt(plaintext, public_key1)\n    decrypted_with_key1 = rsa_decrypt(encrypted_with_key1, private_key1)\n    encrypted_with_key2 = rsa_encrypt(plaintext, public_key2)\n    decrypted_with_key2 = rsa_decrypt(encrypted_with_key2, private_key2)\n    assert decrypted_with_key1 == plaintext, \"Decrypted text should match the original with key pair 1\"",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_large_data_encryption",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_large_data_encryption():\n    \"\"\"Test RSA encryption and decryption with a chunking approach (demonstrative).\"\"\"\n    private_key, public_key = generate_rsa_keys()\n    plaintext = \"A\" * 1000  # Demonstrative chunking\n    chunk_size = 190  # Based on RSA key size minus padding overhead\n    encrypted_chunks = [rsa_encrypt(plaintext[i:i+chunk_size], public_key) for i in range(0, len(plaintext), chunk_size)]\n    decrypted_chunks = [rsa_decrypt(chunk, private_key) for chunk in encrypted_chunks]\n    decrypted_text = ''.join(decrypted_chunks)\n    assert decrypted_text == plaintext, \"Decrypted text should match the original large plaintext\"\ndef test_rsa_decryption_with_wrong_key():",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_decryption_with_wrong_key",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_decryption_with_wrong_key():\n    \"\"\"Test RSA decryption fails when using a wrong private key.\"\"\"\n    private_key1, public_key1 = generate_rsa_keys()\n    private_key2, _ = generate_rsa_keys()  # Correct private key is not used\n    plaintext = \"Critical data\"\n    encrypted = rsa_encrypt(plaintext, public_key1)\n    try:\n        rsa_decrypt(encrypted, private_key2)\n        assert False, \"Decryption should fail but succeeded\"\n    except Exception as e:",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_public_key_reuse",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_public_key_reuse():\n    \"\"\"Test reusing the same public key for multiple encryptions.\"\"\"\n    private_key, public_key = generate_rsa_keys()\n    plaintexts = [\"Message 1\", \"Message 2\", \"Message 3\"]\n    encrypted_texts = [rsa_encrypt(pt, public_key) for pt in plaintexts]\n    decrypted_texts = [rsa_decrypt(et, private_key) for et in encrypted_texts]\n    assert all(dt == pt for dt, pt in zip(decrypted_texts, plaintexts)), \"All decrypted texts should match their original plaintexts\"\ndef test_rsa_padding_oracle_attack_scenario():\n    \"\"\"Simulate a scenario that should be resistant to padding oracle attacks.\"\"\"\n    private_key, public_key = generate_rsa_keys()",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "test_rsa_padding_oracle_attack_scenario",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_encryption_decryption",
        "description": "SecureEncoderFlask.tests.test_encryption_decryption",
        "peekOfCode": "def test_rsa_padding_oracle_attack_scenario():\n    \"\"\"Simulate a scenario that should be resistant to padding oracle attacks.\"\"\"\n    private_key, public_key = generate_rsa_keys()\n    plaintext = \"Very sensitive data\"\n    encrypted = rsa_encrypt(plaintext, public_key)\n    # Correct XOR operation for tampering demonstration\n    encrypted_bytes = bytes.fromhex(encrypted)\n    tampered_ciphertext = encrypted_bytes[:-1] + bytes([encrypted_bytes[-1] ^ 0x01])\n    tampered_hex = tampered_ciphertext.hex()\n    try:",
        "detail": "SecureEncoderFlask.tests.test_encryption_decryption",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_md5_model",
        "description": "SecureEncoderFlask.tests.test_md5_model",
        "peekOfCode": "def app():\n    app = create_app({\n        'TESTING': True,\n        'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',\n        'WTF_CSRF_ENABLED': False  # Disable CSRF tokens in the form for testing purposes.\n    })\n    with app.app_context():\n        db.create_all()\n    return app\n@pytest.fixture",
        "detail": "SecureEncoderFlask.tests.test_md5_model",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_md5_model",
        "description": "SecureEncoderFlask.tests.test_md5_model",
        "peekOfCode": "def client(app):\n    return app.test_client()\ndef test_md5_encode(app):\n    # Use app context here for database operations\n    with app.app_context():\n        text = \"hello world\"\n        encoded = md5_encode(text)\n        stored_hash = MD5Hash.query.first()\n        assert stored_hash.md5_hash == encoded  # Ensure it's correctly stored in DB\n        assert len(encoded) == 32  # MD5 hashes should be 32 characters long",
        "detail": "SecureEncoderFlask.tests.test_md5_model",
        "documentation": {}
    },
    {
        "label": "test_md5_encode",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_md5_model",
        "description": "SecureEncoderFlask.tests.test_md5_model",
        "peekOfCode": "def test_md5_encode(app):\n    # Use app context here for database operations\n    with app.app_context():\n        text = \"hello world\"\n        encoded = md5_encode(text)\n        stored_hash = MD5Hash.query.first()\n        assert stored_hash.md5_hash == encoded  # Ensure it's correctly stored in DB\n        assert len(encoded) == 32  # MD5 hashes should be 32 characters long\ndef test_md5_decode(app):\n    with app.app_context():",
        "detail": "SecureEncoderFlask.tests.test_md5_model",
        "documentation": {}
    },
    {
        "label": "test_md5_decode",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_md5_model",
        "description": "SecureEncoderFlask.tests.test_md5_model",
        "peekOfCode": "def test_md5_decode(app):\n    with app.app_context():\n        text = \"hello world\"\n        encoded = md5_encode(text)\n        decoded = md5_decode(encoded)\n        assert decoded == text  # Ensure the decoded text matches the original\ndef test_md5_decode_no_match(app):\n    with app.app_context():\n        decoded = md5_decode(\"nonexistenthash\")\n        assert decoded == \"No match found\"  # Ensure correct message is returned when no match is found",
        "detail": "SecureEncoderFlask.tests.test_md5_model",
        "documentation": {}
    },
    {
        "label": "test_md5_decode_no_match",
        "kind": 2,
        "importPath": "SecureEncoderFlask.tests.test_md5_model",
        "description": "SecureEncoderFlask.tests.test_md5_model",
        "peekOfCode": "def test_md5_decode_no_match(app):\n    with app.app_context():\n        decoded = md5_decode(\"nonexistenthash\")\n        assert decoded == \"No match found\"  # Ensure correct message is returned when no match is found",
        "detail": "SecureEncoderFlask.tests.test_md5_model",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "description": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "description": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "description": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "description": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "SecureEncoderReact.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "def stringify(value):\n    return _stringify(value, separators=(',', ':'))\nassert stringify([None, None]) == '[[null,null]]'\na = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "a = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['o']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "b = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['one']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['two']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['three']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['a']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['test']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['array']",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "a2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o2",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "o2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "str = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "oo",
        "kind": 5,
        "importPath": "SecureEncoderReact.node_modules.flatted.python.test",
        "description": "SecureEncoderReact.node_modules.flatted.python.test",
        "peekOfCode": "oo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "SecureEncoderReact.node_modules.flatted.python.test",
        "documentation": {}
    }
]